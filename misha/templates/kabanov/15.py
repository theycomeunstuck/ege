'''
Что нужно знать?
∧ ----> and
v  ----> or
→   ----> <=
=   ----> ==
≠   ----> !=
ДЕЛ ----> %
/  -----> //  округляется в меньшую сторону. 5//2==2 


Стоит использовать числа в переборе как можно больше!
один раз можно сделать с небольшими числами, а другой - с большими

not использовать не стоит. or do it as |(not (func) ) |
'''

'''Делимость'''
for a in range(1, 100):
    for x in range(1, 10000):  # стоит ставить число побольше
        if (x % 34 == 0) and (x % 51 != 0) <= ((x % a == 0)) <= ((x % a != 0) or (x % 51 == 0)) == 0:
            break
    else:
        # print(a)
        pass
# for else -- выполнение блока else in case when "for" was not breaked


'''Конъюкция'''


def f(x): return (x & 41 == 0) <= ((x & 119 != 0) <= (x & a != 0))

for a in range(1, 100):  # интервал.
    if all(f(x) == 1 for x in range(1, 10000)):
        # print(a)
        pass

'''Числовая плоскость'''


def f(x, y): return (y + 3 * x < a) or (x > 20) or (y > 40)

for a in range(1, 200):
    if all(f(x, y) == 1 for x in range(1, 100) for y in range(1, 100)):
        # print(a)
        pass
# ! Если в условии сказано "целые неотрицательные значения", то перебор x,y начинается с 0 / for x in range(0,100) for y in range(0,100)
# Если в функции n кол-во переменных, то в f(x,y, n) ; for x for y for n


''' Множество '''
# лучше решать ручками


# Поиск минимального множества.
# а) берём пустое а
# б) заполняем его числа, для которых условие ложно

a = set()
b = {2, 4, 6, 8, 10, 12}
c = {3, 6, 9, 12, 15}
def f(x):
    A = x in a
    B = x in b
    C = x in c
    return B <= ((C and (not A)) <= (not B))


for x in range(1000):
    if f(x) == 0:
        a.add(x)
# print(a)

''''''''''''
# Поиск наибольшего множества.
# а) берём большое множество А
# б) убираем из него неподходящие числа

a = set(range(1000))
def f(x):
    A = x in a
    P = x in {2, 4, 6, 8, 10, 12, 14, 16, 18, 20}
    Q = x in {5, 10, 15, 20, 25, 30, 35, 40, 45, 50}
    return (A <= P) and ((Q <= (not(A))))

for x in range(1000):
    if f(x) == 0:
        a.remove(x)
# print(a)



''' Отрезки ''' #most hard что может выпасть. #   №4972
# ! Если получается дробный ответ, то нужно округлить в большую сторону до целого числа !

from itertools import *

def f(x):
    P = 25 <= x <= 50
    Q = 54 <= x <= 75
    A = a1 <= x <= a2
    return Q <= ((P==Q) or ((not P) <= A))

Ox = [i/4 for i in range(24*4, 76*4)] #вся числовая прямая с шагом 0.25
# for i in range( ((МИН ЧИСЛО НА ОТРЕЗКЕ) - 1)*4, ((МАКС ЧИСЛО НА ОТРЕЗКЕ) + 1)*4)
m = []

for a1, a2 in combinations(Ox, 2):
    if all(f(x) == 1 for x in Ox):
        m.append(a2-a1)
print(min(m))


