#Во многих заданиях помогает functool @lru_cache
#setrecursionlimit
#очень оптимизирован код [31-41]

import sys
from functools import lru_cache

sys.setrecursionlimit(1000000)

'''
траектория не содержит числа 23.
траектория содержит число 12'''
def f(c,e):
    if c > e or c == 23: return 0
    if c == e: return 1
    if c < e: return f(c+1,e)+f(2*c+1, e)

print(f(1,12)*f(12,25))


'''
(№ 3446) У исполнителя Калькулятор есть три команды, которым присвоены номера:
1. Прибавить 1
2. Прибавить 5
3. Умножить на 3

Сколько разных чисел может быть получено из числа 1 с помощью программ, состоящих из 4 команд?
'''

def f(curr, step):
    if step == 4: d.add(curr)
    else:
        f(curr+1, step+1)
        f(curr+5, step+1)
        f(curr*3, step+1)

d = set()
f(1,0)
print(len(d))


'''
(№ 3710) Исполнитель Нолик преобразует двоичное число, записанное на экране. У исполнителя есть три команды, которым присвоены номера:
1. Прибавить 1
2. Добавить справа 0
3. Добавить справа 1

Сколько существует программ, которые исходное двоичное число 101 преобразуют в двоичное число 101110? 
/comment | Первая команда увеличивает число на 1. При выполнении второй команды, исполнитель справа к числу приписывает 0, а при выполнении третьей команды справа к числу приписывает 1. 
(например, для числа 10 результатом работы данных команд будут являться числа 100 и 101 соответственно).
'''
#/comm | жёсткий лайфхак, связанный с 5 номером. хз, я думаю, что можно в крайнем случае всё на жёсткий понос пустить, а именно в
#в функции насрать перевод с int в bin и там дальше пойдёт по трубам...
#    !Добавить справа 0 —— n*2
#    !Добавить справа 0 —— 2*n+1
@lru_cache(None)
def f(c,e):
    if c > e: return 0
    if c == e: return 1
    if c < e: return f(c+1, e) + f(c*2, e) + f(2*c+1, e)

#переведём двоичные числа в нормальные
start, target = int("101",2), int("101110", 2)
print(f(start, target))


'''
(№ 4949) Исполнитель Калькулятор преобразует число, записанное на экране. У исполнителя есть три команды, которым присвоены номера:

1. Прибавь 1
2. Прибавь 2
3. Умножь на 2
Сколько существует программ, которые преобразуют исходное число 1 в число 12 и при этом не содержат двух команд «Прибавить 2» подряд? 
'''

def f(c,e,prev):
    if c > e: return 0
    if c == e: return 1
    if c < e and prev == '+2': return f(c+1,e,'+1')+ f(c*2,e,'*2')
    if c < e and prev != '+2': return f(c+1,e,'+1')+ f(c+2, e, '+2') + f(c*2,e,'*2')


print(f(1,12,0))