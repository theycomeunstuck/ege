"""
alternative solution by alexey kabanov.
https://www.youtube.com/watch?v=saqqoCS6wjk&
"""

'''
                ordinary case. one heap
+2/*2 by step. S >= 25 -- win. S from start == 1 ≤ S ≤ 24.
'''

#@lru_cache(None) #does not really reduce time compiling/ so can be removed.
def f(s, m):
    if s >= 25: return m % 2 == 0
    if m == 0: return 0 #ходов больше нет.
    h = [f(s+2,m-1), f(s*2,m-1)]
    return any(h) if (m-1) % 2 == 0 else all(h) # in case "bad step" replace <<all(h)>> by <<any(h)>>
    #    also can be << m%2 != 0 >> instead of << (m-1) % 2 == 0 >>


#dynamic print /so we should change for every task
print('19:', [s for s in range(1,25) if (s,2)])
print('20:', [s for s in range(1,25) if not f(s,1) and f(s,2)])
print('21:', [s for s in range(1,25) if (s,2)])

## <<m>> means remains of steps. steps described as:
##             [p1, v1, p1, v2] == [1, 2, 3, 4] (previous solution was hit it as: [1, -1, 2, -2]
## step 0 can be readen as m=0 when print



#important.
# - Ваня может выиграть своим первым ходом после одного из ходов Пети -- needed extra check. manual is pretty simple.



''' case when we can not repeat last step (step by enemy)'''
def f(s, m, p):
    if s >= 140: return m % 2 == 0
    if m == 0: return 0
    h = []
    if p != '+1': h += [f(s+1, m-1, '+1')]
    if p != '+2': h += [f(s+2, m-1, '+2')]
    if p != '*3': h += [f(s*3, m-1, '*3')]

    return any(h) if (m-1) % 2 == 0 else all(h)
print('\n19:', [s for s in range(1,140) if f(s,2, '')])


'''
5782
Снегурочка и Дед Мороз играют в следующую игру: перед ними лежит куча подарков. Игроки ходят по очереди, первый ход делает Снегурочка. За один ход игрок может добавить 2 подарка, 5 подарков, 12 подарков или увеличить их количество в два раза. При этом нельзя повторять ход, который этот же игрок делал на предыдущем ходу. Для того чтобы делать ходы, у каждого игрока есть неограниченное количество подарков. Игра завершается в тот момент, когда суммарное количество подарков станет не менее 121. Победителем считается игрок, сделавший последний ход, т.е. первым получивший такую позицию, при которой в куче будет не меньше, чем 121 подарок. В начальный момент в куче было S подарков; 1 ≤ S ≤ 120. Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника.
Ответьте на следующие вопросы:
  Вопрос 1. Известно, что Дед Мороз выиграл своим первым ходом после неудачного первого хода Снегурочки. Укажите минимальное значение S, когда такая ситуация возможна.
  Вопрос 2. Укажите минимальное S, при котором одновременно выполняются два условия:
– у Снегурочки есть выигрышная стратегия, позволяющая ей выиграть своим вторым ходом при любой игре Деда Мороза;
– у Снегурочки нет стратегии, которая позволит её гарантированно выиграть первым ходом.
  Вопрос 3. Найдите максимальное и минимальное значения S, при которых
– у Деда Мороза есть выигрышная стратегия, позволяющая ему выиграть, по крайней мере, своим третьим ходом при любой игре Снегурочки;
– у Деда Мороза нет стратегии, которая позволит ему гарантированно выиграть первым или вторым ходом.
Найденные значения запишите в ответе в порядке возрастания.

            case when we can not repeat our previous step (player can not repeat his step)'''


def f(s, m, p1, p2):
    if s >= 121: return m % 2 == 0
    if m == 0: return 0
    h = []
    if p2 != '+2': h += [f(s+2, m-1, '+2', p1)]
    if p2 != '+5': h += [f(s+5, m-1, '+5', p1)]
    if p2 != '+12': h += [f(s+12, m-1, '+12', p1)]
    if p2 != '*2': h += [f(s*2, m-1, '*2', p1)]
    return any(h) if m % 2 != 0 else all(h)

print('\n19:', [s for s in range(1, 121) if f(s,2, '', '')]) #{31, ...} / replace <<all>> to <<any>> to get right answer.
print('20:', [s for s in range(1, 121) if not f(s,1, '', '') and f(s,3, '', '')])
print('21:', [s for s in range(1, 121) if not f(s,4, '', '') and f(s,6, '', '')])


